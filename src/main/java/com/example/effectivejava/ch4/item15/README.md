# item15: 클래스와 멤버의 접근 권한을 최소화하라

* 모든 클래스와 멤버의 접근성을 가능한 한 좁혀야 한다.
* 클래스의 공개 API(public)를 필요한 경우에 세심히 설계하되, 그 외의 모든 멤버는 private 으로 만든다.
* public 가변 필드를 갖는 클래스는 일반적으로 스레드 안전(Thread-Safe)하지 않다.
* 만약 공개 범위를 점점 넓히는 상황이 자주 일어난다면 책임 분리를 고민하자.

## 만약 public 불변 필드를 갖는다면?

```java
public class Something {
    public final int data;
    ...
}
```

외부에서 해당 필드를 변경할 수는 없지만, Something 클래스의 내부 구현을 바꾸고 싶어도, public 필드인 data 를 없애는 것은 힘들다. 왜냐하면 해당 필드는 외부 클래스에서 접근하고 있을 수도
있으므로 변경에 유연하지 못하며 변경 비용이 클 것이다.
(내부 구현이 아닌 외부 클래스를 수정해야만 한다. 즉, 개방-폐쇄 원칙을 위배한다.)

## final 이지만, 참조형을 고려해보자

아래와 같이, final 이지만 값을 참조하는 정수형 배열을 고민해보자

```java
public class Something {
    public final int[] numbers = {1, 2, 3, 4, 5};
}
```

numbers 의 인스턴스 참조는 변경될 수 없지만(새로운 배열을 할당할 수 없지만), 각각의 배열 요소에 접근해서 배열 요소를 변경할 수는 있다.

```java
Something.numbers[0]=-1;
```

해당 클래스의 캡슐화를 지키려면 해당 배열을 priavate 지정하고 필요한 경우에 불변 배열을 반환하도록 한다.

외부에서 해당 필드를 변경할 수는 없지만, Something 클래스의 내부 구현을 바꾸고 싶어도, public 필드인 data 를 없애는 것은 힘들다. 왜냐하면 해당 필드는 외부 클래스에서 접근하고 있을 수도
있으므로 변경에 유연하지 못하며 변경 비용이 클 것이다.
(내부 구현이 아닌 외부 클래스를 수정해야만 한다. 즉, 개방-폐쇄 원칙을 위배한다.)

## private 메서드는 어떻게 테스트하나?

만약 public 클래스의 private 메서드를 테스트하고 싶다면, private 메서드를 package-private(default) 까지 풀어주는 것은 허용하되 그 이상은 안된다.
